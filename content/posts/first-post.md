---
title: "C언어 기초 함수의 취약점(Overflow, Buffer remnant) 이해"
date: 2026-02-06T00:36:38+09:00
draft: false
---

### 기본입력 / 출력함수
#### 형변환 문자
아래는 형식지정자를 나타낸다
 - %d : 정수(decimal)
 - %c : 문자(character)
 - %s : 문자열(string)
 - %f : 실수(소수점 6자리)

#### printf(), scanf()
- printf()
	- 형식 지정자에 맞춰 내용 출력
- scanf()
	- 형식 지정자에 맞춰 입력을 받아 변수에 저장

#### getcahr(), putchar()
- getchar()
	- 단일 문자를 읽어 정수형으로 변환
	- 정수형으로 변환하는 이유는 아스키코드로 변환해 문자를 출력
- putchar()
	- 단일 문자를 출력

#### gets(), puts()
- gets()
	- 한 줄 문자열 전체를 입력받아 변수에 저장
	- Buffer Overflow 위험으로 fgets() 사용
- puts()
	- 문자열을 출력하고 개행 추가

위의 개념들을 가지고 어떤 취약점을 가지고있는지 실습을 통해 알아보자
1. [[C언어 기초 함수의 취약점(Overflow, Buffer remnant) 이해#gets()를 이용한 Stack Buffer Overflow 실습|gets()를 이용한 Stack Buffer Overflow 실습]]
2. [[C언어 기초 함수의 취약점(Overflow, Buffer remnant) 이해#scanf()와 %s의 위험성 실습|scanf()와 %s의 위험성 실습]]
3. [[C언어 기초 함수의 취약점(Overflow, Buffer remnant) 이해#getchar()와 입력 Buffer 찌꺼기 활용 공격 실습|getchar()와 입력 Buffer 찌꺼기 활용 공격 실습]]
4. [[C언어 기초 함수의 취약점(Overflow, Buffer remnant) 이해#printf() Format String 맛보기 실습|printf() Format String 맛보기 실습]]


#### gets()를 이용한 Stack Buffer Overflow 실습
가장 클래식한 취약점 실습이다. `gets()`가 왜 **금지된 함수**인지 확인해보자.
- **실습 방법:** `char buf[5];`와 같이 아주 작은 배열을 선언하고 `gets(buf);`로 입력을 받는다.
- **공격 시도:** 5글자가 아니라 `AAAAAAAAAAAA...`처럼 아주 긴 문자열을 입력해 본다.
- **관찰 포인트:** 배열 뒤에 있는 다른 변수의 값이 다른 문자로 바뀌지는 않는가?
- **보안 교훈:** 입력값의 길이를 검증하지 않는 함수는 대문을 열어둔 것과 같다.
```C
#include <stdio.h>
#include <string.h>

int main() {
    char admin_pw[5] = "9999"; 
    char buf[5]; 

    printf("비밀번호 입력: ");
    gets(buf); // 5글자 이상 넣으면 admin_pw를 침범함
    //fgets(buf, sizeof(buf), stdin);

    printf("입력값: %s / 실제 비번: %s\n", buf, admin_pw);
    
    if (strcmp(buf, admin_pw) == 0) printf("=> 성공: 권한 획득\n");
    else printf("실패: 권한 없음\n");

    return 0;
}
```
- **입력 값:** `999999998` (9글자).
- **현상:** `buf`의 크기(5칸)를 넘친 데이터가 인접한 메모리 영역인 `admin_pw`를 덮어씀
- **결과:** `admin_pw`의 값이 원래 "9999"에서 입력값의 일부인 "9998"로 변조됨을 확인.
- **취약점:** `gets()`
- **보완점:** `fgets(buf, sizeof(buf), stdin);`
- **이유:** `fgets()`는 사용자가 아무리 길게 입력해도 정해진 `sizeof(buf)` 만큼만 읽으므로, 옆 칸인 `admin_pw`를 절대 침범할 수 없음.

#### scanf()와 %s의 위험성 실습
`scanf()`는 형식을 지정하니까 안전하다고 오해하지만 `%s`는 `gets()`와 마찬가지로 입력 길이를 제한하지 않는다.
- **실습 방법:** `char name[10];`을 선언하고 `scanf("%s", name);`으로 입력을 받는다.
- **공격 시도:** 10글자가 아니라 `1234567890ABCDEFG`처럼 배열 크기를 초과하는 긴 문자열을 입력한다.
- **관찰 포인트:** `name[10]`의 범위를 넘긴 데이터가 메모리 경계를 침범하여 인접 변수를 오염시키거나 덤프가 발생하는지 확인한다.
- **보안 교훈:** 입력의 '형태'를 지정하는 것보다 중요한 것은 입력의 '한계'를 지정하는 것이다.
```C
#include <stdio.h>

int main() {
    char name[10];
    printf("이름 입력: ");
    
    // 공격 시나리오: scanf("%s", name); (길이 제한 없음)
    // 방어 시나리오: scanf("%9s", name); (딱 9자만 받음)
    scanf("%s", name); 

    printf("저장된 이름: %s\n", name);
    return 0;
}
```
- **입력 값:** `1234567890ABCDEFG` (10자 초과).
- **현상:** `name[10]`의 크기를 넘긴 데이터가 메모리 경계를 침범.
- **결과:** 프로그램이 강제 종료(`Segmentation Fault`)되거나 인접한 변수의 값이 오염됨.
- **취약점:** `%s`는 공백을 만날 때까지 무한정 읽어 들이기 때문에 배열 크기보다 긴 입력에 무방비함.
- **보완점:** `scanf("%9s", name);`처럼 숫자를 명시하여 읽어올 길이를 강제로 제한해야 함.
- **이유**: null을 제외한 9개 까지의 문자를 저장하므로 Stack Buffer Overflow를 방지 할 수 있음.

#### getchar()와 입력 Buffer 찌꺼기 활용 공격 실습
메모리 파괴가 아닌 프로그램의 **논리적 흐름**을 비틀어 인증이나 절차를 우회하는 기법이다.
- **실습 방법:** `getchar()`로 첫 글자(`Y/N`)를 받고, 곧바로 아래에서 `scanf()`로 비밀번호를 입력받는다.
- **공격 시도:** 첫 번째 입력 시 `Y`만 치지 않고 `Y1234`처럼 뒤에 데이터를 붙여서 입력한 후 엔터를 누른다.
- **관찰 포인트:** 다음 입력 함수가 사용자 입력을 기다리지 않고, 버퍼에 남은 `1234`를 자동으로 낚아채서 실행되는 현상을 확인한다.
- **보안 교훈:** 남겨진 버퍼 찌꺼기는 프로그램의 통제권을 해커에게 넘겨주는 실마리가 된다.
```C
#include <stdio.h>

int main() {
    char yn;
    char pw[10];

    printf("동의하십니까? (Y/N): ");
    yn = getchar(); // 첫 1바이트만 가져감

    printf("비밀번호 설정: ");
    // 엔터(\n)를 만날 때까지 버퍼에서 문자를 계속 꺼내서 버립니다.
    //while (getchar() != '\n');
    scanf("%s", pw); // 버퍼에 남은 찌꺼기가 있다면 입력을 대기하지 않음

    printf("선택: %c, 설정된 비번: %s\n", yn, pw);
    return 0;
}
```
- **입력 값:** `Y1234` 입력 후 엔터
- **현상:** `getchar()`가 `Y`만 처리하고, 남은 `1234`와 `\n`이 입력 버퍼(stdin)에 그대로 잔류함.
- **결과:** 사용자가 비밀번호를 입력할 기회도 없이 버퍼의 `1234`가 `pw` 변수에 자동 할당됨.
- **취약점**: 입력 버퍼에 잔류된 문자를 처리하지 않음.
- **보완점**: while문을 사용한 입력버퍼를 초기화하거나 getchar()또는 scanf() 대신 fgets() 사용
- **이유:** 입력 버퍼 초기화가 누락되면 사용자의 의도와 다른 데이터가 변수에 주입될 수 있음.

#### printf() Format String 맛보기 실습
데이터가 출력되어야 할 위치에 공격자의 명령(서식 지정자)이 끼어들어 **시스템 내부 정보를 유출**하는 공격입니다.
- **실습 방법:** `char user_input[100];`에 입력을 받고, `printf(user_input);`과 같이 서식 지정자 없이 변수를 직접 출력한다.
- **공격 시도:** 입력창에 `%p %p %p %p`와 같은 서식 지정자를 입력해 본다(%p는 포인터 주소값 출력서식 지정자).
- **관찰 포인트:** 입력한 문자가 그대로 출력되는 대신, 현재 스택(Stack) 메모리에 저장된 **실제 주소값**들이 16진수로 출력되는지 확인한다.
- **보안 교훈:** 사용자의 입력을 직접 함수 인자로 넣는 행위는 시스템 내부 지도를 해커에게 넘겨주는 것과 같다.
```C
#include <stdio.h>

int main() {
    char user_input[100];
    printf("메시지를 입력하세요: ");
    fgets(user_input, sizeof(user_input), stdin);

    printf("\n[출력 결과]: ");
    printf(user_input);
    printf("\n");

    return 0;
}
```
- **입력 값:** `%p %p %p %p`
- **현상:** `printf`가 사용자 입력을 단순 문자열이 아닌 출력 명령어로 해석함.
- **결과:** 스택 메모리에 저장된 민감한 주소값들이 노출되어 보안 장치 무력화의 단초를 제공함.
- **취약점:** printf()의 서식 지정자(%s) 누락
- **보완점:**`printf("%s", user_input);` 처럼 서식 문자를 포함한 포맷 문자열(Format String)을 첫 번째 인자로 명시하여 데이터와 형식을 엄격히 분리함.
- **이유:** `printf` 함수의 첫 번째 인자는 출력 형식을 결정하는 '명령어 가이드' 역할을 하기 때문임. 여기에 사용자의 입력을 직접 넣으면, 함수는 입력값 내에 포함된 `%p`, `%x`, `%n` 등을 **실제 메모리를 읽거나 쓰라는 명령어**로 인식하여 실행하게 됨.



